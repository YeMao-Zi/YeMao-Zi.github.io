---
title: 组合式API
date: 2022-06-26 17:46:59
permalink: /pages/97d256/
categories:
  - 《Vue》笔记
  - 可复用性&组合
tags:
  - 
author: 
  name: 夜猫子
  link: https://github.com/zhushengjie123
titleTag: 
---
# **组合式 API**

作用：将逻辑关注点相同的代码收集到一起去。

## **全新的组合式勾子：setup**

> `setup` 中无法使用 `this`:  因为`setup` 发生在 `data`、`computed` 或 `methods` 被解析之前。
>
> 因此 `setup` 中只能访问到 `props`、`attrs`、`slots`、`emit`。

### 参数

`setup` 中接受 `props` 和 `context` 并将返回的内容暴露给组件的其他部分(计算属性、方法、生命周期钩子等等) 以及组件的模板。

1. 其中 `props` 是响应式的，所以不能使用 `ES6` 的解构赋值，如要解构则需使用 `torefs(props)` 来包裹。

2. `context` 是一个普通 JavaScript 对象，暴露了其它可能在 `setup` 中有用的值：

- `attribute` 是元素标签的属性，property 是元素对象的属性

- input 的 value `attribute` 是通过标签里的 `value=“test value”` 定义的，可以通过`input.getAttribute(‘value’)` 获取，可以通过 `input.setAttribute(‘value’, ‘New Value’)` 更新
- `input` 的 `value` `property` 可通过 `input.value` 获取和更新，初始值是与 `attribute` 中的赋值一致的

```js
export default {
  setup(props, context) {
      
    // Attribute (非响应式对象，等同于 $attrs)    
    console.log(context.attrs)

    // 插槽 (非响应式对象，等同于 $slots)
    console.log(context.slots)

    // 触发事件 (方法，等同于 $emit)
    console.log(context.emit)

    // 暴露公共 property (函数)，可以解决返回渲染函数时无法return返回其他内容的问题
    console.log(context.expose)
  }
}
```

## **带 ref 的响应式变量**

使通过值传递的 `string` 和 `number` 类型也能变得响应式。

`reactive`：用法与 `ref` 类似，不同的是`ref`用于基本数据类型，而`reactive`是用于复杂数据类型，比如对象和数组。

`toRefs`：对`props`的响应式封装，作用为使本身具有响应式特点的 `props` 可以使用解构赋值。

```js
import { ref, reactive } from 'vue'//暴露出ref，reactive对象

const counter = ref(0)//使用ref封装值
const user = reactive({ name: "Alice", age: 12 })//reactive封装
console.log(counter) // { value: 0 }
counter.value++
console.log(counter.value) // 1//已经是可响应式了
```

```js
import { ref, onMounted, watch, toRefs } from 'vue'
setup (props) {
  // 使用 `toRefs` 创建对 `props` 中的 `user` property 的响应式引用
  const { user } = toRefs(props)
  }
```

## **setup 中的生命周期勾子**

组合式 `api` 中的生命周期勾子与声明式一样，但前缀为 `on`：即  `onMounted`

> 需要注意的是，`vue3`中将 `destoryed` 重新命名为  `unmounted` ;  `beforeDestroy` 被修改为 `beforeUnmount`
>
> 此外，因为 `setup` 是围绕 `beforeCreate` 和 `created` 生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在两个钩子中编写的任何代码都应该直接在 `setup` 函数中编写。

```js
// src/components/UserRepositories.vue `setup` function
<template>
  <div>{{ value1 }}</div>
/* 在模板中使用setup的返回值时，refs被浅解析，因此不应使用.value*/
</template>

import { ref, onMounted } from 'vue'

// 在我们的组件中
setup (props) {
  const value1 = ref([])
  const fn =  () => {
    value1.value = 2
  }
  
  onMounted(fn) // 在 `mounted` 时调用函数 `fn`

  return {
    value1,
    fn
  }
}
```

## **监听属性 watch**

其接受三个参数

- 一个想要侦听的**响应式引用**或 getter 函数
- 一个回调
- 可选的配置选项

```js
import { ref, watch } from 'vue'

const counter = ref(0)
watch(counter, (newValue, oldValue) => {
  console.log('The new counter value is: ' + counter.value)
})
```

##  独立的 `computed` 属性

如watch、ref,通过导入属性可以实现在vue组件外部使用

```js
import { ref, computed } from 'vue'

const counter = ref(0)
const twiceTheCounter = computed(() => counter.value * 2)
```

## 渲染函数

 `expose` ：使 `return` 渲染函数时，同时对外可以暴露自定义 `property`

```js
import { h, ref, reactive } from 'vue'

export default {
  setup() {
    const readersNumber = ref(0)
    const book = reactive({ title: 'Vue 3 Guide' })//复杂数据的ref封装
    
    const count = ref(0)
    const increment = () => ++count.value

    expose({//借助expose,类似于 return ，传递出 increment 对象
      increment
    })
    // 请注意这里我们需要显式使用 ref 的 value
    return () => h('div', [readersNumber.value, book.title，count.value])
  }
}
```

## Provide Inject

### 使用 `provide` 

`setup` 中的 `provide` 函数允许你通过两个参数定义 property：

1. name (`<String>` 类型)
2. value

~~~vue
<!-- src/components/MyMap.vue -->
<template>
  <MyMarker />
</template>
<script>
import { provide } from 'vue'
import MyMarker from './MyMarker.vue'

export default {
  components: {
    MyMarker
  },
  setup() {
    provide('location', 'North Pole')
    provide('geolocation', {
      longitude: 90,
      latitude: 135
    })
    //或是进行响应式包装，使子孙组件能够响应父组件的改变
    //const location = ref('North Pole')
    //const geolocation = reactive({
    //  longitude: 90,
    //  latitude: 135
    //})
    //provide('location', location)
    //provide('geolocation', geolocation)
    //return {
    //	location
    //}
  },
  methods: {
    updateLocation() {//此处修改 provide 数据
      this.location = 'South Pole'
    }
  }
}
</script>
~~~
> 建议：如果要对响应式的 provide / inject 进行修改时，尽可能的在定义的组件内修改。
>
> 如果需要在接收数据的组件内更新 inject 数据，可以类似于组件通讯一般，父组件将修改方法传递过去，然后在子组件内调用。
### 使用 `Inject` 

`inject` 函数有两个参数：

1.  `inject` 的 `property` 的 `name`
2. 默认值 (**可选**),如未取到第二个值，则给其一个默认值

~~~vue
<!-- src/components/MyMarker.vue -->
<script>
import { inject } from 'vue'

export default {
  setup() {
    const userLocation = inject('location', 'The Universe')//对inject进行重构
    const userGeolocation = inject('geolocation')

    return {
      userLocation,
      userGeolocation
    }
  }
}
</script>
~~~

### 子组件内更新 `inject` 的情况

>  推荐对 property 使用 `readonly` 确保通过 `provide` 传递的数据不会被 inject 的组件更改。

~~~vue
<!-- src/components/MyMap.vue （祖先组件）-->
<template>
  <MyMarker />
</template>

<script>
import { provide, reactive, readonly, ref } from 'vue'
import MyMarker from './MyMarker.vue'

export default {
  components: {
    MyMarker
  },
  setup() {
    const location = ref('North Pole')
    const geolocation = reactive({
      longitude: 90,
      latitude: 135
    })

    const updateLocation = () => {
      location.value = 'South Pole'
    }

    provide('location', readonly(location))//使用了readonly
    provide('geolocation', readonly(geolocation))
    provide('updateLocation', updateLocation)
  }
}
</script>
~~~



```vue
<!-- src/components/MyMarker.vue -->
<script>
import { inject } from 'vue'

export default {
  setup() {
    const userLocation = inject('location', 'The Universe')
    const userGeolocation = inject('geolocation')
    const updateUserLocation = inject('updateLocation')

    return {
      userLocation,
      userGeolocation,
      updateUserLocation
    }
  }
}
</script>
```

## 侦听模板引用

与生命周期钩子的一个关键区别是，`watch()` 和 `watchEffect()` 在 DOM 挂载或更新*之前*运行副作用，所以当侦听器运行时，模板引用还未被更新。

若想确保模板引用与 DOM 保持同步，并引用正确的元素，应该用 `flush: 'post'` 选项来定义。

```vue
<template>
  <div ref="root">This is a root element</div>
</template>

<script>
  import { ref, watchEffect } from 'vue'

  export default {
    setup() {
      const root = ref(null)

      watchEffect(() => {
        console.log(root.value) // => <div>This is a root element</div>
      }, 
      {//若未加该选项，则上一行将输出 null
        flush: 'post'
      })

      return {//传递出 root 后，被模板引用，于是该模板被定义给了 root 的值
        root
      }
    }
  }
</script>
```
