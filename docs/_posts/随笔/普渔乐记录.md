## 路由

```js
// router.config.js

constantRouterMap<router>：//基础路由。含login(登录)，register(注册)，register-result(注册)。目前只有登录
localRouterMap<router>：//本地路由。
```

~~~js
//generator-router.js

rootRouter<router>: // 根路由
notFoundRouter<router>: // 不存在的路由，即404

generatorDynamicRouter<function>: // 生成动态路由菜单
	1.调取动态路由接口。
    2.调用listMapList函数将返回值转化为符合路由规则的菜单数组。
    3.将转化值加入到上面rootRouter的子路由中；并将notFoundRouter路由和更路由平级放入[]中，生成可用的路由格式。
    4.暴露出路由结果。
    
listMapList函数: // 路由路径提升
	1.在映射中定义需要提升的路由
	2.遍历路由，查看是否有在映射中存在的路由(子路由含有详情和其他操作页面，需要提升子路由路径)
    	(1)将该路由设置为二级路由(一级路由为根路由'/')
	    (2)提取出子路由(之后会将其与其父路由放在同一级成为二级路由)
    	(3)如果子路由中还存在映射中存在的路由，进行递归迭代
    	(4)在一级路由的 children 中添加进提取出的路由
~~~

~~~js
//premission.js(全局路由守卫)

#有token情况：
	1.如果进入登录路由，定向至根路由
    2.判断是否有角色信息，无则调取action中的登录接口函数获取角色数组；有则直接放行。
      成功后调取action中的获取动态路由回调，该函数调用了上面 generator-router.js 中的 generatorDynamicRouter 生成动态菜单方法。
      生成动态菜单路由成功后，获取 router.config.js 中的基础路由，将基础路由与动态路由合并，生成最终的路由菜单（但还未应用）。
    3.获取用户信息失败时，调取action中的调用登出回调，清空token等登录信息，记录下当前页面路径（用于redirect），然后跳转至登录页面。
    4.通过 router.addRoute()函数将生成的路由菜单替换为生效的 router;   
    5.如果有重定向标记，进行重定向跳转。如果进入页面和重定向页面一致，进行历史记录保留操作（配置 replace: true ）；否则直接跳转。
#无token情况：
	1.如果是进入登录，注册页面，放行。
	2.否则记录下当前页面路径（用于redirect），然后跳转至登录页面。
~~~

### 登录一系列流程

没找到判断

~~~js
1.只有基础路由，其中首页被定向为登录路由
2.表单验证通过后，调取action中的异步函数，储存token，并将token储存在vuex中， 然后跳转至根路由；异步失败调接口刷新验证码。
3.跳转时进行路由守卫。
~~~

## 订单管理

### 容器

~~~
-面包屑
--卡片容器
---封装好的搜索框工具栏
---table表格
~~~

其中table个性化表格（\#*bodyCell*）中的参数：

~~~html
<!-- 
	record:绑定的当前行数据;
	column:触发的column信息(自己定义的那个);
	index:当前行数据下标(所在行);
	text:该列绑定的值(column中定义的dataIndex) 
-->
~~~



### 使用的封装工具

`FormSearch` 组件：搜索框工具栏

`v-permission` 指令：权限控制

### 相关页面

点击详情=>跳转至订单详情路由（可通过编程式路由导航将id带过去）。

个采和集采是同一个页面，不同路由，通过路由元信息来区分。

## 商品管理

### 容器

~~~
-面包屑
--卡片容器
---封装好的搜索框工具栏
---table表格
~~~

### 使用的封装工具

`FormSearch` 组件：搜索框工具栏

`v-permission` 指令：权限控制

### 相关页面

点击编辑=>跳转至商品编辑路由（可通过编程式路由导航将id带过去）。

#### 商品编辑

##### 容器

~~~
-面包屑
--卡片容器
---渲染加载容器
----form表单
~~~

##### 过程

```js
mounted：
  #通过标识获取集采或个采对应的总分类列表
  #通过id获取对应的商品信息
  	0.主要的商品信息
	1.商品分类id
	2.主图的url
	3.sku列表（包含规格信息）
    
基础信息: 与获取的数据直接绑定
说明信息：直接绑定

规格信息与sku列表：将获取到的sku信息提取出来并进行加工处理
   -每条sku信息处理：skuFormState.products
    1.定义编辑状态 isEdit = false
    2.定义上传状态 uploading = false
    3.定义主图url并进行加工成数组格式
    每条sku信息组成新数组
   -规格信息 skuFormState.skus
    遍历并拿出所有的规格信息，组成键值对对象
    将该对象进行加工生成可遍历的数组
    即将[{key: "默认1", value: "默认2"}] =转化成=>
[
    {
        "key": "默认1",
        "isEdit": false,
        "values": [
            {
                "key": "1", //下标索引做key
                "value": "默认2"
            }
        ]
    }
]
（这样就可以进行新增规格值操作）
每次数据更改后都重新更新column，遍历后添加：
{title: sku.key, //默认1
 dataIndex: sku.key, //默认1
 key: 'sku-item'}

下拉框绑定的数组
item来自skuFormState.skus 中 values 的遍历
[{ label: item.value, value: item.value }......]
//[{ label: 默认2, value: 默认2 }......]

下拉框绑定的数据
 <a-select
     v-if="record.isEdit"
     placeholder="请选择"
     v-model:value="record[column.dataIndex]"
     :options="skuValuesOptions(column.dataIndex)"
     style="width: 100%"
></a-select>

const skuValuesOptions = computed(() => {
  return (key) => {
    return skuFormState.skus
      .find((item) => item.key === key)
      .values.map((item) => ({ label: item.value, value: item.value }));
  };
});
```

## 前置仓管理

### 腾讯地图的点击和搜索功能

**1、腾讯位置服务[申请密钥](https://lbs.qq.com/dev/console/application/mine)**

**2、vue项目index.html引入**

```html
<script src="https://map.qq.com/api/gljs?v=1.exp&key=申请的密钥"></script>
如：
<script src="https://map.qq.com/api/gljs?v=1.exp&libraries=service&key=GSVBZ-HDZ6W-L73RX-OWEGZ-S4NMF-MOBZF"></script>
```

**3、引入jsonp（非必须）**

script 本身是跨域的，但如果失败可以下载 jsonp 。

1）安装vue-jsonp：

```
cnpm install vue-jsonp --save
```

2）在main.js中导入

```
import { VueJsonp } from 'vue-jsonp'
Vue.use(VueJsonp)
```

### 组件中使用

~~~vue
<template>
    <div className="mapContainer">
        <div id="map"></div>
        <div className="pannel">
            <el-input v-model="search" placeholder="回车检索" style="width: 200px" @change="onSearch(search)">
            </el-input>
        </div>
    </div>
</template>

<script  setup>
import { ref, onMounted, onUnmounted, defineEmits, defineProps, watch, } from 'vue';

onMounted(() => {
    initMap(39.916527, 116.397128);
    setTimeout(() => {
        console.log(prop)
    }, 2000)
});
onUnmounted(() => {
    mapRef.destroy()
})

const prop = defineProps({
    address: {
        type: String,
        default: ''
    },
})
const emit = defineEmits(['onFinished'])

watch(() => prop.address, (n) => {
    onSearch(n)
})
let markets;// 初始标记物
let mapRef; // 初始地图信息，建议组件销毁时一起销毁
const search = ref(''); // 初始地址搜索


//初始化地图
const initMap = (lat, lng) => {
    // 定义地图坐标
    const center = new TMap.LatLng(lat, lng);

    //绘制地图
    //new TMap.Map(domId, options);domId:(必填) 地图DOM容器的id;options:地图参数.
    const map = new TMap.Map("map", {
        rotation: 20, //设置地图旋转角度
        pitch: 0, //设置俯仰角度（0~45）
        zoom: 16, //设置地图缩放级别
        center: center, //设置地图中心点坐标
        viewMode: '2D',
    });

    // 创建点标记
    markets = new TMap.MultiMarker({
        map,//指定点标记图层所覆盖的地图容器   
        geometries: [],// 设置点标记数据      
        // geometries: [{
        //   id: 'demo',//指定点标记id
        //   position: new TMap.LatLng(39.9821, 116.3131, 134)// 标记位置(经度，纬度，高度)
        // }......],
    });


    // 定义地图上的点击行为
    map.on('click', (evt) => {
        // 将点击的坐标定义为地图的中心坐标
        const location = new TMap.LatLng(evt.latLng.lat, evt.latLng.lng);
        // 设置中心坐标
        map.setCenter(location);
        //更新数据，重置标记，根据图层类型传入对应的Geometry对象。
        markets.setGeometries([]);
        // 将给定的坐标位置转换为地址
        geocoder.getAddress({ location }).then((res) => {
            const result = res.result;
            console.log(result, 'result')
            // 在点击的坐标处绘制标记
            markets.updateGeometries([
                {
                    id: 'main',
                    position: location,
                },
            ]);

            // 包含点击的坐标的一系列信息
            // console.log(result)
            emit('onFinished', result)
        });
    });

    mapRef= map;
    // marketsRef.value = markets;
};

// 新建一个正逆地址解析类,用于进行地址和坐标轴的转化
const geocoder = new TMap.service.Geocoder();
// 定义搜索方法
const onSearch = (searchValue) => {
    //更新数据，重置标记，根据图层类型传入对应的Geometry对象，此时空数组表示为清空标记
    markets.setGeometries([]);
    // 将给定的地址转化为坐标
    geocoder.getLocation({ address: searchValue }).then((res) => {
        const result = res.result;
        // 在搜索的坐标处绘制标记
        markets.updateGeometries([
            {
                id: 'main',
                position: result.location,
            },
        ]);
        // 将搜索的坐标设置中心坐标
        mapRef.setCenter(result.location);

        // 包含搜索的坐标的一系列信息
        // console.log(result)
    });
}
~~~

## 商城sku控制

### 矩阵图思路

#### 1.初始化顶点集和空邻接矩阵

这部分并没有修改，与原相同，代码实现如下所示：

```js
// 构造初始空邻接矩阵存储无向图
initEmptyAdjMatrix() {
  this.properties.forEach((prop) => {
    prop.attributes.forEach((attr) => {
      this.vertexList.push(attr.value);
    });
  });
  for (let i = 0; i < this.vertexList.length; i++) {
    this.matrix[i] = new Array(this.vertexList.length).fill(0);
  }
},
```
#### 2.邻接矩阵赋值

setAdjMatrixValue 调用子函数 associateAttributes 时需要增加传参 skuId ，对于 properties 赋值的情况没有 skuId ，统一传一个能够确认与 skuList 中的每一个 skuId 不相同的值即可，这里传1：

```js
// 根据 skuList 和 properties 设置邻接矩阵的值
setAdjMatrixValue() {
  this.skuList.forEach((sku) => {
    this.associateAttributes(sku.attributes, sku.id);
  });
  this.properties.forEach((prop) => {
    this.associateAttributes(prop.attributes, '1');
  });
},
```
在子函数 associateAttributes 中，赋值时需要修改逻辑，判断 this.matrix[index1][index2] 是否有值，若有值，则使用 add 方法在集合中增加当前传入的 skuId，否则赋值为新创建的 Set 对象，并在集合中增加当前传入的 skuId。

```js
// 将 attributes 属性组中的属性在无向图中联系起来
associateAttributes(attributes, skuId) {
  attributes.forEach((attr1) => {
    attributes.forEach((attr2) => {
      // 因 properties 与 skuList 数据结构不一致，需作处理
      if (attr1 !== attr2 || attr1.value !== attr2.value) {
        if (attr1.value && attr2.value) {
          attr1 = attr1.value;
          attr2 = attr2.value;
        }
        const index1 = this.vertexList.indexOf(attr1);
        const index2 = this.vertexList.indexOf(attr2);
        if (index1 > -1 && index2 > -1) {
          if(this.matrix[index1][index2]) {
            this.matrix[index1][index2].add(skuId);
          }
          else {
            this.matrix[index1][index2] = new Set([skuId]);
          }
        }
      }
    });
  });
},
```

**赋值后，邻接矩阵如下所示：**

1L	4L	红色	黑色	套餐一	套餐二
1L	0	{1}	{10}	{20}	{10}	{20}
4L	{1}	0	{30, 40}	0	{30}	{40}
红色	{10}	{30, 40}	0	{1}	{10, 30}	{40}
黑色	{20}	0	{1}	0	0	{20}
套餐一	{10}	{30}	{10, 30}	0	0	{1}
套餐二	{20}	{40}	{40}	{20}	{1}	0

#### 3.判断 attribute 是否可选

原逻辑是判断得到的 res 数组中是否每个值均为1，若符合则可选；否则若其中一个值为0，则不可选置灰。
修改后的逻辑更为复杂，感觉这块有可能出bug。如果有小伙伴发现了评论区告诉我～
我的思路是：此时 res 数组中存储的元素可能有两种类型，Number 类型的 0 或者 Object 类型的 Set 对象， Set 对象中存储的可能为 1 或者 skuList 中存在的 skuId， 1 和 skuId是 String 类型。我将结果区分为三种情况，注意三种情况有先后关系，后一种排除前一种存在的可能，即使用 if - else if - else 的控制流：

- 若 res 数组中存在值为 0 的元素，则返回 false ，表示需要置灰，这种情况与原逻辑相同

- 排除上一种情况之后，此时 res 数组中存储的是 Set 对象， Set 对象存储的是 1 或者 skuId。若 res 数组中存在包含值为 1 的 Set 对象，则返回 true ，表示可选。
- 排除以上两种情况之后，此时 res 数组中存储的是 Set 对象， Set 对象中存储的是 skuId。当且仅当每个 Set 对象中包含相同的一个 skuId 时，可选返回 true，否则不可选返回 false
- 一、三情况比较容易理解，对于第二种情况举例说明：选择了 1L 和 红色 之后，4L 能不能选呢？此时对于 4L 这个 attribute， res 数组应为 [{'1'}, {'30', '40'}] ，数组中不包含 0 且包含 1，此时应该是可选的。

代码实现如下所示：

```js
// 判断当前 attribute 是否可选，返回 true 表示可选，返回 false 表示不可选，选项置灰
canAttributeSelect(attribute) {
  if (!this.selected || !this.selected.length || attribute.isActive) {
    return true;
  }
  let res = [];
  this.selected.forEach((value) => {
    const index1 = this.vertexList.indexOf(value);
    const index2 = this.vertexList.indexOf(attribute.value);
    res.push(this.matrix[index1][index2]);
  });
  // console.log(attribute.value, '->', res);
  if(res.some((item)=> (item === 0))) {
    return false;
  }
  else if(res.some((item) => (item.has('1')))) {
    return true;
  }
  else {
    const first = res[0];
    const others = res.slice(1);
    return Array.from(first).some((skuId) => (others.every((item) => (item.has(skuId)))));
  }
},
```
### 源码

#### data.js 初始数据模拟

~~~js
export const properties = [
  {
    id: "1",
    name: "容量",
    attributes: [
      { value: "1L", isActive: false, isDisabled: false },
      { value: "4L", isActive: false, isDisabled: false },
    ],
  },
  {
    id: "2",
    name: "颜色",
    attributes: [
      { value: "红色", isActive: false, isDisabled: false },
      { value: "黑色", isActive: false, isDisabled: false },
    ],
  },
  {
    id: "3",
    name: "优惠套餐",
    attributes: [
      { value: "套餐一", isActive: false, isDisabled: false },
      { value: "套餐二", isActive: false, isDisabled: false },
    ],
  },
];

export const skuList = [
  { id: "10", attributes: ["1L", "红色", "套餐一"] },
  { id: "20", attributes: ["1L", "黑色", "套餐二"] },
  { id: "30", attributes: ["4L", "红色", "套餐一"] },
  { id: "40", attributes: ["4L", "红色", "套餐二"] },
];
~~~

#### 实现页面

~~~vue
<template>
  <div class="root">
    <p>商品多规格选择示例2.0</p>
    <div v-for="(property, propertyIndex) in properties" :key="propertyIndex">
      <p>{{ property.name }}</p>
      <div class="sku-box-area">
        <template v-for="(attribute, attributeIndex) in property.attributes">
          <div
            :key="attributeIndex"
            :class="[
              'sku-box',
              'sku-text',
              attribute.isActive ? 'active' : '',
              attribute.isDisabled ? 'disabled' : '',
            ]"
            @click="handleClickAttribute(propertyIndex, attributeIndex)"
          >
            {{ attribute.value }}
          </div>
        </template>
      </div>
    </div>
  </div>
</template>

<script>
import { properties, skuList } from '../data';

export default {
  name: "SkuSelector2",
  components: {},
  computed: {},
  data() {
    return {
      properties: [], // property 列表
      skuList: [], // sku 列表
      matrix: [], // 邻接矩阵存储无向图
      vertexList: [], // 顶点数组
      selected: [], // 当前已选的 attribute 列表
    };
  },
  mounted() {
    this.properties = properties;
    this.skuList = skuList;

    this.initEmptyAdjMatrix();
    this.setAdjMatrixValue();
  },
  methods: {
    // 当点击某个 attribute 时，如：黑色
    handleClickAttribute(propertyIndex, attributeIndex) {
      const attr = this.properties[propertyIndex].attributes[attributeIndex];
      // 若选项置灰，直接返回，表现为点击无响应
      if (attr.isDisabled) {
        return;
      }

      // 重置每个 attribute 的 isActive 状态
      const isActive = !attr.isActive;
      this.properties[propertyIndex].attributes[attributeIndex].isActive =
        isActive;
      if (isActive) {
        this.properties[propertyIndex].attributes.forEach((attr, index) => {
          if (index !== attributeIndex) {
            attr.isActive = false;
          }
        });
      }

      // 维护当前已选的 attribute 列表
      this.selected = [];
      this.properties.forEach((prop) => {
        prop.attributes.forEach((attr) => {
          if (attr.isActive) {
            this.selected.push(attr.value);
          }
        });
      });

      // 重置每个 attribute 的 isDisabled 状态
      this.properties.forEach((prop) => {
        prop.attributes.forEach((attr) => {
          attr.isDisabled = !this.canAttributeSelect(attr);
        });
      });
    },
	//无向图设计说明：
    //1.值为0：为默认值，没有该组合
    //2.值为1：同标签数据
    //3.值含skuid:该组合包含在一组sku组合中(可能含多个skuid)
    // 构造初始空邻接矩阵存储无向图
    initEmptyAdjMatrix() {
      this.properties.forEach((prop) => {
        prop.attributes.forEach((attr) => {
          this.vertexList.push(attr.value);
        });
      });
      for (let i = 0; i < this.vertexList.length; i++) {
        this.matrix[i] = new Array(this.vertexList.length).fill(0);
      }
    },

    // 根据 skuList 和 properties 设置邻接矩阵的值
    setAdjMatrixValue() {
      this.skuList.forEach((sku) => {
        this.associateAttributes(sku.attributes, sku.id);
      });
      this.properties.forEach((prop) => {
        this.associateAttributes(prop.attributes, '1');// 无向图，中含1的标识为同标签
      });
    },

    // 将 attributes 属性组中的属性在无向图中联系起来
    associateAttributes(attributes, skuId) {
      attributes.forEach((attr1) => {
        attributes.forEach((attr2) => {
          // 因 properties 与 skuList 数据结构不一致，需作处理
          if (attr1 !== attr2 || attr1.value !== attr2.value) {
            if (attr1.value && attr2.value) {
              attr1 = attr1.value;
              attr2 = attr2.value;
            }
        	const value1 = attr1.value ? attr1.value : attr1;
        	const value2 = attr2.value ? attr2.value : attr2;
        	const index1 = dataSource.vertexList.indexOf(value1);
        	const index2 = dataSource.vertexList.indexOf(value2);
            if (index1 > -1 && index2 > -1) {
              if(this.matrix[index1][index2]) {
                this.matrix[index1][index2].add(skuId);
              }
              else {
                this.matrix[index1][index2] = new Set([skuId]);
              }
            }
          }
        });
      });
    },

    // 判断当前 attribute 是否可选，返回 true 表示可选，返回 false 表示不可选，选项置灰
    canAttributeSelect(attribute) {
      if (!this.selected || !this.selected.length || attribute.isActive) {
        return true;
      }
      let res = [];
      this.selected.forEach((value) => {
        const index1 = this.vertexList.indexOf(value);
        const index2 = this.vertexList.indexOf(attribute.value);
        res.push(this.matrix[index1][index2]);
      });
      console.log(attribute.value, '->', res);
      if(res.some((item)=> (item === 0))) {
        return false;
      }
      else if(res.some((item) => (item.has('1')))) {
        return true;
      }
      else {
        const first = res[0];
        const others = res.slice(1);
        return Array.from(first).some((skuId) => (others.every((item) => (item.has(skuId)))));
      }
    },
  },
};
</script>

<style>
.root {
  width: 350px;
  padding: 24px;
}
.sku-box-area {
  display: flex;
  flex: 1;
  flex-direction: row;
  flex-wrap: wrap;
}
.sku-box {
  border: 1px solid #cccccc;
  border-radius: 6px;
  margin-right: 12px;
  padding: 8px 10px;
  margin-bottom: 10px;
}
.sku-text {
  font-size: 16px;
  line-height: 16px;
  color: #666666;
}
.active {
  border-color: #ff6600;
  color: #ff6600;
}
.disabled {
  opacity: 0.5;
  border-color: #e0e0e0;
  color: #999999;
}
</style>

~~~



## 其他

### Tab 标签与 Scroll 的联动

~~~html
<!--HTML代码-->

 <div class="scroll">
	<div class="tab">
         <!--为了方便Tab的样式，其中 <a-tabs> 来自UI库-->
            <a-tabs
                :activeKey="current"
                @change="changeTab"
            >
                <a-tab-pane tab="模块1" :key="0"></a-tab-pane>
                <a-tab-pane tab="模块2" :key="1"></a-tab-pane>
                <a-tab-pane tab="模块3" :key="2"></a-tab-pane>
            </a-tabs>
 	</div>
    <div>
 		<div class="block">
     		模块1内容...
 		</div>
 		<div class="block">
    		 模块2内容...
 		</div>
 		<div class="block">
     		模块3内容...
 		</div>
	</div>
</div>
~~~

~~~js
//JS代码

const current=0 // Tab 标签的下标位置
const scrollLock=false // 滚动条是否触发回调（防止点击 Tab 后套娃）

const scrollEl = document.getElementsByClassName("scroll")[0];//获取滚动条 DOM

const targetEl = document.getElementsByClassName("block");//获取 滚动条的联动内容 DOM

//监听滚动条，触发滚动条回调事件
scrollEl.addEventListener("scroll",scrollEvent);

/**
* @changeTab tab点击回调
*/
function changeTab(val) {
    // 因为 HTMLCollection 型数据无法被遍历，通过call来强行关联
    let targetValueMap = Array.prototype.map.call(
        this.targetEl,
        (i) => i.offsetTop + 3
    );
    current = val;
    scrollLock = true;
    // 设置滚动条的滚动距离为目标元素与容器的上边距
    scrollEl.scrollTop = targetValueMap[val];
    setTimeout(() => {
        scrollLock = false;
    }, 100);
},
    
/**
 * @scrollEvent 滚动回调
 */
function scrollEvent(e) {
    if (this.scrollLock) {
        return false;
    }
    // 获取当前滚动距离
    let currentValue = e.target.scrollTop;
    // 获取各元素与容器的上边距的集合
    let targetValueMap = Array.prototype.map.call(
       	targetEl,
        (i) => i.offsetTop + 3
    );
    let activeKey = 0;
    // 判断当前滚动距离处于何处元素范围
    targetValueMap.forEach((item, index) => {
        if (currentValue > item) {
            activeKey = index;
        }
    });
    current = activeKey;
},
~~~

### 将 HTMLCollection 类型数据转化未可遍历数组

~~~js
const arr=  Array.prototype.slice
                    .call(targetEl)
                    .map((i) => i.offsetTop + 3)
// 因此上面的 scrollEl.scrollTop 可以设置为：
scrollEl.scrollTop=arr.map(i=> i.offsetTop + 3)
~~~

