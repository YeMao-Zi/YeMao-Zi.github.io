# 初始化一个 vue-ts 项目

## 创建 ts 项目

```haskell
yarn create vite YMlist --template vue-ts
```

## vscode 支持插件

### TypeScript Vue Plugin (Volar)

官方出品的插件，对 Vue3 有最好的支持。注意：不兼容 Vue2。

### Vue3 sniappets

支持关键词快捷键入 vue3 相关代码。

### Prettier

代码格式化校验工具。

## 配置 lint

### eslint

使用 vite 创建的项目与 cli 创建的不一样，是没有 eslint，所以需要手动配置。

```bash
# eslint 和 eslint vue 插件
npm install --save-dev eslint eslint-plugin-vue

# vite 接入 eslint
npm install vite-plugin-eslint --save-dev

# eslint 插件，为 ts 代码提供 lint 规则
npm i @typescript-eslint/parser @typescript-eslint/eslint-plugin --save-dev
```

### prettier

主要是为了多人协作时代码风格统一。

```shell
# eslint-plugin-prettie 用于将 prettier 的 错误报错给 eslint
# eslint-config-prettier 因为 eslint 和 prettier 都可以去做格式化代码，这就造成两者在使用上会出现冲突，它主要负责两者的冲突
npm install prettier eslint-plugin-prettier eslint-config-prettier --save-dev
```

### 创建 .eslintrc.json 文件

```json
{
  "env": {
    "browser": true,
    "node": true
  },
  "extends": [
    "eslint:recommended",
    "plugin:vue/vue3-recommended",
    "prettier",
    "plugin:prettier/recommended"
  ],
  "plugins": ["vue", "@typescript-eslint"],
  "parserOptions": {
    "ecmaVersion": 12,
    "parser": "@typescript-eslint/parser",
    "sourceType": "module"
  },
  "rules": {
    "vue/multi-word-component-names": "off", // 创建 vue 组件时，可以使用单个单词
    "no-unused-vars": [
      "error",
      {
        "varsIgnorePattern": ".*",
        "args": "none",
        "vars": "all",
        "ignoreRestSiblings": true,
        "argsIgnorePattern": "^_"  // 声明但未使用的变量，当变量名以 _ 为前缀时，可忽略错误
      }
    ]
  }
}
```

### 代码风格格式化校验

添加.prettierrc.js文件配置：

可根据个人或团队风格调整。

```js
module.exports = {
  printWidth: 80, //单行长度
  tabWidth: 2, //缩进长度
  useTabs: false, //使用空格代替tab缩进
  semi: true, //句末使用分号
  singleQuote: true, //使用单引号
  quoteProps: 'as-needed', //仅在必需时为对象的key添加引号
  jsxSingleQuote: true, // jsx中使用单引号
  trailingComma: 'all', //多行时尽可能打印尾随逗号
  bracketSpacing: true, //在对象前后添加空格-eg: { foo: bar }
  jsxBracketSameLine: true, //多属性html标签的‘>’折行放置
  arrowParens: 'always', //单参数箭头函数参数周围使用圆括号-eg: (x) => x
  requirePragma: false, //无需顶部注释即可格式化
  insertPragma: false, //在已被preitter格式化的文件顶部加上标注
  proseWrap: 'preserve', //使用默认的折行标准
  htmlWhitespaceSensitivity: 'ignore', //对HTML全局空白不敏感
  vueIndentScriptAndStyle: false, //不对vue中的script及style标签缩进
  endOfLine: 'lf', //结束行形式
  embeddedLanguageFormatting: 'auto', //对引用代码进行格式化
};
```

### vite 接入 eslint

使用之前下载的插件 `vite-plugin-eslint`，此 vite 插件可以将 eslint 的错误信息展示到浏览器上。

在 vite.config.ts 中引入 eslintPlugin。

```ts
import eslintPlugin from 'vite-plugin-eslint';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [eslintPlugin()]
})
```

## 配置路径别名

导入 path 时，可能会报类型错误，需安装  `@types/node`

```bash
npm install --save-dev @types/node
```

### vite.config.js

```ts
import { resolve } from "path";

export default defineConfig({
  plugins: [eslintPlugin(), vue()],
  resolve: {
    alias: {
      "@": resolve(__dirname, "src"),
    },
  },
});
```

### tsconfig.json

然后在 tsconfig.json 中进行 TS 配置

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    }
  }
}
```

## 配置 vue-router

```bash
yarn add vue-router@4
```

### 配置 router 

```ts
// router/index.ts
import { createRouter,createWebHashHistory } from "vue-router";
import type { RouteRecordRaw } from "vue-router";

const routes:RouteRecordRaw[]=[
{
    path:'/',
    name:'home',
    component:()=>import ('@/pages/home/index.vue'),
    meta:{
        title:'首页'
    }
},
{
    path:'/',
    name:'calendar',
    component:()=>import ('@/pages/calendar/index.vue'),
    meta:{
        title:'日历'
    }
},{
    path:'/',
    name:'hosettingme',
    component:()=>import ('@/pages/setting/index.vue'),
    meta:{
        title:'设置'
    }
},
]

const router=createRouter({
    history:createWebHashHistory(), // hash 模式
    routes
})

export default router
```

### 注册 router

```ts
// main.ts
import { createApp } from 'vue'
import router from "./routers";
import './style.css'
import App from './App.vue'

createApp(App).use(router).mount('#app')
```

```vue
<!-- App.vue -->
<template>
 <RouterView></RouterView>
</template>

<style lang="stylus" scoped>
</style>
```

### 路由缓存 keep-alive

> 注意：vue3 的路由缓存的写法和 vue2 不一样了（[文档地址](https://router.vuejs.org/zh/guide/migration/#router-view-、-keep-alive-和-transition)）。

缓存 home 和 setting 组件

```vue
<router-view v-slot="{ Component }">
  <keep-alive :include="['home', 'setting']">
    <component :is="Component" />
  </keep-alive>
</router-view>
```

## 配置 Pinia

```bash
yarn add pinia
```

注册

```ts
// main.ts
import { createPinia } from "pinia";
app.use(createPinia())
```

### 定义模块化的 store

#### 定义单个模块 store 

```ts
// stores/modules/calendar.ts
import {defineStore} from "pinia"

const useCalendarStore=defineStore({
    id:"calendar",
    state: () => ({
        isStartSunday: false,
      }),
      actions:{
        setStartSundaySync(value:boolean){
            this.isStartSunday=value
        },
        async setStartSunday() {
            const data = await getInfo();
            this.isStartSunday = data;
          },
      }
})

export default useCalendarStore
```

#### 导出模块

```ts
import useCalendarStore from "./modules/calendar"

/*
* 组件中使用
* import { storeToRefs } from 'pinia'
* import useStore from '@/store'
* const { useCalendarStore } = useStore()
*
* 提交 action
* useCalendarStore.setStartSundaySync(true) 
* 
* 获取数据
* 使用storeToRefs可以保证解构出来的数据也是响应式的
* const { isStartSunday } = storeToRefs(useCalendarStore)
*/
export default function useStore() {
    return {
        useCalendarStore: useCalendarStore(),
    };
  }
```

## 配置 axios

>  关于 Axios 和 TS，其实方案有很多，但每个团队有自己的习惯和规范，没有最好，用起来爽就好了。

```bash
yarn add axios
```

### Axios+TS案例

#### request 函数

```ts
import axios from "axios"
import type {AxiosRequestConfig} from "axios"
import { getRequestBaseURL } from "./index";

const axiosInterface = axios.create({
  baseURL: getRequestBaseURL(),
  timeout: 10000,
  headers: {
    "content-type": "application/json",
  },
});

const request = async <T>(
  config: AxiosRequestConfig
): Promise<API.BaseResponseType<T>> => {
  try {
    const { data } = await axiosInterface(config);
    return data;
  } catch (error) {
    return Promise.reject(error);
  }
};
```

##### 声明一个全局 API 命名空间

```ts
declare namespace API {
    type BaseResponseType<T> =Readonly<{
     code: number;
     message: string;
     data: T;
   }>
 }
```

##### 使用时的泛型约束

```ts
interface loginByPasswordRequset{
    accessToken: string;
    refreshToken: string;
}
export const loginByPassword = async (loginInfo: LoginByPassword) => {
  return await request<loginByPasswordRequset>({
    url: "/user/loginByPassword",
    method: "post",
    data: loginInfo,
  });
};
```

#### Token 处理

在实际业务中，token 是不可能长期生效的，因此我们需要对 token 失效的情况进行处理。

比如上面，登录接口返回了两个 token，`accessToken` 和 `refreshToken`，有效时间分别为 2天 和 4天；

在用户使用过程中，如果后端返回 401 状态码，就代表 `accessToken` 过期了。这时候就要缓存过期后的请求函数，同时发送一个新的请求并携带 `refreshToken` 去从后端获取新的 token，并在获取 token 后，重新执行之前缓存过的请求函数。

如果获取新 token 的请求返回的状态码非 200，那么代表 `refreshToken` 也过期了，这时候需要跳转到登录页，重新登录。

##### 添加请求拦截

```ts
// 请求拦截
axiosInterface.interceptors.request.use((config) => {
    const token = localStorage.getItem(UserTokenEnum.ASSET_TOKEN);
    if (token) {
      const { headers } = config;
      headers.Authorization = `Bearer ${token}`;
    }
    return config;
})
```

##### 添加响应拦截

```ts
// 缓存 token 过期后的请求函数
let catchRequestFunc: Array<() => void> = [];
// 响应拦截
axiosInterface.interceptors.response.use(
    async (response: AxiosResponse<API.BaseResponseType<any>>) => {
        const { status, data } = response;
        if (status === 200) {
            const { code, message } = data;
            const responseCode = Number(code);
            // token 过期
            if (responseCode == 401) {
                // 缓存过期后的请求函数
                new Promise((resolve) => {
                    catchRequestFunc.push(() => {
                        resolve(request(response.config));
                    });
                });
                // 通过 reference token 获取新 token
                await handleRefreshToken();
            } else if (responseCode === 403) {
                router.push({
                    name: "homePage",
                });
            } else if (responseCode !== 200) {
                // 业务中非 200 的状态码一律弹出
                MessageApi.error(message);
            }
        }
        return response;
    },
    ({ response }) => {
        // 请求失败，也弹出状态码
        MessageApi.error(netWorkCodeMaps[response.status] || "服务器错误");
    }
);
```



### 完整代码

```ts
import axios from "axios"
import router from "@/routers";
import { getRequestBaseURL } from "./index"
import useStore from '@/stores'
import { useMessage } from "naive-ui";

import type { AxiosRequestConfig, AxiosResponse } from "axios"
import { UserToken } from "@/types/user";

const MessageApi = useMessage();
const { useGlobalStore } = useStore()

const netWorkCodeMaps: Record<number, string> = {
    404: "404 Not Found",
    405: "Method Not Allowed",
    504: "网关错误",
    500: "服务器错误",
} as const;

const axiosInterface = axios.create({
    baseURL: getRequestBaseURL(),
    timeout: 10000,
    headers: {
        "content-type": "application/json",
    },
});

// 缓存 token 过期后的请求函数
let catchRequestFunc: Array<() => void> = [];

// 请求拦截
axiosInterface.interceptors.request.use((config) => {
    const token = localStorage.getItem(UserToken.ASSET_TOKEN);
    if (token) {
        const { headers } = config;
        headers.Authorization = `Bearer ${token}`;
    }
    return config;
});

// 响应拦截
axiosInterface.interceptors.response.use(
    async (response: AxiosResponse<API.BaseResponseType<any>>) => {
        const { status, data } = response;
        if (status === 200) {
            const { code, message } = data;
            const responseCode = Number(code);
            // token 过期
            if (responseCode == 401) {
                // 缓存过期后的请求函数
                new Promise((resolve) => {
                    catchRequestFunc.push(() => {
                        resolve(request(response.config));
                    });
                });
                // 通过 reference token 获取新 token
                await handleRefreshToken();
            } else if (responseCode === 403) {
                router.push({
                    name: "homePage",
                });
            } else if (responseCode !== 200) {
                // 业务中非 200 的状态码一律弹出
                MessageApi.error(message);
            }
        }
        return response;
    },
    ({ response }) => {
        // 请求失败，也弹出状态码
        MessageApi.error(netWorkCodeMaps[response.status] || "服务器错误");
    }
);

const handleRefreshToken = async () => {
    const refreshToken = localStorage.getItem(UserToken.REFRESH_TOKEN);

    if (refreshToken) {
        const { code, data } = await request<{
            accessToken: string;
            refreshToken: string;
        }>({
            url: "/user/refreshToken",
            method: "post",
            data: {
                refreshToken: window.localStorage.getItem(UserToken.REFRESH_TOKEN),
            },
        });
        if (Number(code) === 200) {
            localStorage.setItem(UserToken.ASSET_TOKEN, data.accessToken);
            localStorage.setItem(UserToken.REFRESH_TOKEN, data.refreshToken);

            axiosInterface.defaults.headers[
                "Authorization"
            ] = `Bearer ${data.accessToken}`;

            // 执行 token 失效后缓存的请求函数
            catchRequestFunc.forEach((catchFunc) => {
                catchFunc();
            });
        } else {
            // refreshtoken 也过期了，那么跳登录页，重新登录
            useGlobalStore.handleLogout();

            catchRequestFunc = [];
            router.push({
                name: "homePage",
            });
            MessageApi.warning("请重新登录");
        }
    } else {
        // 不存在 refresh token, 跳登录页
        useGlobalStore.handleLogout();
        catchRequestFunc = [];
        router.push({
            name: "homePage",
        });
        MessageApi.warning("请重新登录");
    }
};

const request = async<T>(config: AxiosRequestConfig): Promise<API.BaseResponseType<T>> => {
    try {
        const { data } = await axiosInterface(config)
        return data
    } catch (error) {
        return Promise.reject(error);
    }
}
```
