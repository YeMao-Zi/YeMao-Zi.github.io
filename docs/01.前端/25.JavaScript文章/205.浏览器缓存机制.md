---
title: 浏览器缓存机制
date: 2024-08-23 09:58:46
permalink: /pages/llqhcjz/
categories:
  - 前端
  - JavaScript文章
tags:
  - 
author: 
  name: 夜猫子
  link: https://github.com/yemao-zi
titleTag: 
---



# 浏览器缓存机制

浏览器缓存对于前端一点都不陌生，最常见的就是，新版本上线了，测试却说这怎么还没有变化呢？使用 ctr + F5 强制刷新之后，立马就好了。或者清除浏览器缓存，按住ctr+shift+delete，弹出如图：

![前端性能优化(二)——浏览器缓存机制](https://s2.loli.net/2024/08/23/rKt9YoDaAvCXn5F.png)

 

我们会发现目前浏览器缓存的图片和文件的大小。或者进入chrome://chrome-urls/找到chrome://cache/ 就可以看到所有缓存的地址列表。对于浏览器缓存，前端对它是又爱又恨，有时想保留，有时想禁掉，所以看看浏览器缓存到底是怎样的？

<!-- more -->

## 一、什么是浏览器缓存？

浏览器缓存就是浏览器根据 url 第一次访问网站之后，将网站的 html、css、js、图片等文件复制一份保留到浏览器中，当你二次访问这个 url 的网站时，如果网站没有明确表示有更新时，浏览器直接在缓存中查找内容，不会再次请求网页内容，只有网页明确表示有更新时，浏览器才会向服务器发起网路请求，再次下载网页。

![前端性能优化(二)——浏览器缓存机制](https://s2.loli.net/2024/08/23/2yRnQCYsEZ6M5NI.png)

 

如上图，百度首页就是使用了缓存机制，首次访问之后 web资源被缓存，在后面重复请求中，资源直接在缓存中读取，而不是向服务器请求资源。

## 二、为什么使用缓存？

**2.1、为什么很多网站二次打开速度很快？**

　　网页二次打开很快，主要原因是第一次加载页面过程中，缓存了部分耗时数据，这一现象，对于单页面应用开发非常明显。

上一篇文章《浏览器工作原理》中，浏览器工作流程介绍，输入网址回车以后浏览器向服务器发起服务之前，会现在浏览器缓存中查询是否有需要的文件？如果有则直接在缓存中获取文件，避免向服务器请求和下载文件，所以节省了一部分时间。

**2.2、浏览器缓存优点**

1、减少网络带宽消耗

对于网站运营者或者访问网页的用户，带宽就代表着 money ，过多的消耗带宽，我们服务器配置就得升级，使用浏览器缓存之后，就会减少网络流量，降低运营成本。

2、降低服务器压力

使用浏览器缓存之后，除第一次访问需要向服务器请求网站全部资源，后续访问可以重复使用浏览器本地缓存，减少对服务器的请求，间接降低服务器的压力，同时，搜索引擎的爬虫也会根据缓存过期机制降低抓取的频率，也可以降低服务器压力。

3、减少网络延迟，加快网页加载

浏览器缓存 web资源后，减少网络请求，可以更快速地获取到服务器返回数据，同时使用浏览器缓存内的文件比服务器获取快很多，所以网页加载速度明显快很多。

## 三、浏览器的缓存规则

浏览器的缓存判断分为**强缓存**和**协商缓存**以及**启发式缓存**。

::: details 强缓存

浏览器在加载资源时，会先根据本地缓存资源的 header 中的信息判断是否命中强缓存，如果命中则直接使用缓存中的资源不会再向服务器发送请求。

这里的 header 中的信息指的是 expires 和 cahe-control.

:::



::: details 协商缓存

当强缓存没有命中的时候，**浏览器会发送一个请求到服务器**，服务器根据 header 中的部分信息来判断是否命中缓存。如果命中，则返回 304 ，告诉浏览器资源未更新，可使用本地的缓存。

这里的 header 中的信息指的是 Last-Modify/If-Modify-Since 和 ETag/If-None-Match.

:::



::: details 启发式缓存

当没有明确的缓存控制字段（Cache-Control 或 Expires）时，浏览器会根据 Last-Modified 和 Date 字段通过启发式算法计算出缓存时间并自动命中。

启发式缓存和强缓存以及协商缓存有很大的差别，它是一种浏览器的**默认缓存策略**，并非基于HTTP协议的规范，因此不同的浏览器可能会有不同的实现方式。

:::



::: warning

依赖启发式缓存是不明智的，因为它不可预测且可能因浏览器而异，所以**最佳实践是始终为你的资源明确配置 Cache-Control 头部**。

- 对于不常变的文件：`Cache-Control: max-age=31536000, immutable`（长缓存）
- 对于常变的文件：`Cache-Control: no-cache` 或 `Cache-Control: max-age=0`（配合 `Etag`/`Last-Modified` 使用协商缓存）
- 彻底禁止缓存：`Cache-Control: no-store`

明确设置 `Cache-Control` 可以消除不确定性，给你对缓存行为完全的控制权。`Last-Modified` 则应作为一个有用的验证器，与 `Etag`（更可靠）一起配合 `Cache-Control` 使用。

:::



**流程图**

下图清晰地展示了浏览器的缓存决策过程：



```mermaid
graph TD
    A[请求资源] --> B{缓存中有副本?}
    
    B -- 否 --> C[发送普通请求]
    C --> D[服务器返回响应]
    D --> E{检查响应缓存指令}
    
    E -- "A: 有明确缓存指令<br>Cache-Control: max-age=300 / Expires" --> F[遵循明确指令进行缓存和过期计算]
    F --> Z[使用资源]
    
    E -- "B: 明确禁止缓存<br>Cache-Control: no-store" --> G[不缓存响应]
    G --> Z
    
    E -- "C: 无明确指令但有验证器<br>（如 Last-Modified 或 ETag）" --> H["触发启发式缓存计算<br>（例如：缓存时间 = Date - Last-Modified * 10%）"]
    H --> Z
    
    E -- "D: 无任何缓存头或验证器" --> I[通常不进行缓存]
    I --> Z
    
    B -- 有 --> J[缓存有效性检查]
    J --> K{"缓存是否有明确过期时间?<br>Cache-Control/Expires"}
    
    K -- 是 --> L[按明确规则判断是否新鲜]
    K -- 否 --> M[使用之前启发式计算的缓存期判断]
    
    L --> N[缓存是否新鲜?]
    M --> N
    
    N -- 是 --> O["强缓存生效<br>直接从内存/磁盘加载"]
    O --> P[瞬间加载, 无网络请求]
    P --> Z
    
    N -- 否 --> Q[缓存已过期, 需向服务器验证]
    Q --> R["发起条件请求（协商缓存）<br>请求头: If-None-Match (ETag)<br>和/或 If-Modified-Since"]
    
    R --> S{服务器验证资源}
    S -- "304 Not Modified<br>（未修改）" --> T["更新缓存中的响应头<br>并重置新鲜度"]
    T --> U[使用缓存资源]
    U --> Z
    
    S -- "200 OK<br>（已修改）" --> V[返回新内容]
    V --> W[更新缓存]
    W --> Z[使用资源]

    Z[使用资源] --> X(流程结束)
```





对于浏览器端的缓存来讲，这些规则是在 http 协议和 meta 标签中定义的。分别从两个维度：新鲜度和校验值，规定浏览器是否可以直接使用缓存中的副本，还是直接从服务器获取最新资源。

3.1、新鲜度(过期)：浏览器缓存的有效期，缓存必须满足以下两个条件，浏览器才会认为是最新的，可以直接使用。

- 含有完整的过期时间控制头信息，并在有效期内。
- 浏览器已经使用过这个副本，并且在会话中已经检查过新鲜度。

3.2、校验值(验证)：服务器返回资源的时候，会在响应头信息中带上资源实体标签 Entity Tag，可以用来作为浏览器再次请求过程的校验标识，如果发现校验标识不匹配，说明资源已经被修改过或过期，浏览器需要重新请求资源。



## 四、如何控制缓存？

缓存规则可以设置在html的meta标签，也可以设置在http协议头内。

4.1、前端 html 中 meta 标签

在 html 页面中加入缓存设置，代码如下：

```xml
<meta http-equiv="Pragma" content="no-cache"  />
<!-- Pragma是http1.0版本中给客户端设定缓存方式之一 -->
```

上边代码，禁止浏览器缓存，浏览器每次访问网页都要去服务器请求。事实这种禁用缓存形式作用有限：

- 只有IE浏览器才能标识这段 meta 的含义，其他主流浏览器仅认识 “Cache-Control:no-store” 的 meta 标签。
- 在IE浏览器中，并不一定添加 pragma，但是会让当前网页每次都会向服务器发送请求。

4.2、HTTP协议头

http请求和响应头中，与缓存相关的常见类型：

| 规则   | 消息报头          | 值/示例                            | 类型 | 作用                                                         |
| ------ | ----------------- | ---------------------------------- | ---- | ------------------------------------------------------------ |
| 新鲜度 | Pragma            | no-cache                           | 响应 | 告诉浏览器忽略资源的缓存副本，每次访问都需要去服务器拉取【http1.0中存在的字段，在http1.1已被抛弃，使用Cache-Control替代，但为了做http协议的向下兼容，很多网站依旧会带上这个字段】 |
|        | Expires           | Mon, 15 Aug 2016 03:56:47 GMT      | 响应 | 启用缓存和定义缓存时间。告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求【http1.0中存在的字段，该字段所定义的缓存时间是相对服务器上的时间而言的，如果客户端上的时间跟服务器上的时间不一致（特别是用户修改了自己电脑的系统时间），那缓存时间可能就没啥意义了。在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代】 |
|        | Cache-Control     | no-cache                           | 响应 | 告诉浏览器忽略资源的缓存副本，强制每次请求直接发送给服务器，拉取资源，但不是“不缓存” |
|        |                   | no-store                           | 响应 | 强制缓存在任何情况下都不要保留任何副本                       |
|        |                   | max-age=[秒]                       | 响应 | 指明缓存副本的有效时长，从请求时间开始到过期时间之间的秒数   |
|        |                   | public                             | 响应 | 任何路径的缓存者（本地缓存、代理服务器），可以无条件的缓存该资源 |
|        |                   | private                            | 响应 | 只针对单个用户或者实体（不同用户、窗口）缓存资源             |
|        | Last-Modified     | Mon, 15 Aug 2016 03:56:47 GMT      | 响应 | 告诉浏览器这个资源最后的修改时间。服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端【只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间】 |
|        | If-Modified-Since | Mon, 15 Aug 2016 03:56:47 GMT      | 请求 | 其值为上次响应头的Last-Modified值，再次向web服务器请求时带上头If-Modified-Since。web服务器收到请求后发现有头If-Modified-Since则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），包括更新Last-Modified的值，HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304(无需请求，节省浏览)，告知浏览器继续使用所保存的cache |
| 校验值 | ETag              | "fd56273325a2114818df4f29a628226d" | 响应 | 告诉浏览器当前资源在服务器的唯一标识符（生成规则由服务器决定） |
|        | If-None-Match     | "fd56273325a2114818df4f29a628226d" | 请求 | 当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match（Etag的值）。web服务器收到请求后发现有头If-None-Match则与被请求资源的相应校验串进行比对，决定返回200或304 |

各种类型之间的关系和区别：

- Cache-Control 与 Expires：它两作用一样，都表明当前资源的有效期，控制浏览器是取缓存还是直接向服务器获取，Cache-Control可以设置的更细致，如果同时设置，它的优先级高于Expires。
- Last-Modified / ETag 与 Cache-Control / Expires：配置Last-Modified/ETag的情况下，浏览器再次访问URL的资源，还是会发送请求到服务器，询问文件是否已经修改，如果没有，服务器会给浏览器返回304，浏览器直接从本地缓存中取就好了，反之，服务器会直接向浏览器返回数据。Cache-Control / Expires 检测本地缓存是否还在有效期内，在有效期内，直接使用本地缓存，阻止发送请求。如果同时设置，Cache-Control / Expiress 优先级更高。一般情况下，两者配合使用，因为即使服务器设置缓存时间, 当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时Last-Modified/ETag将能够很好利用304，从而减少响应开销。
- Last-Modified 与 ETag：ETag主要是为了解决Last-Modified比较难解决的问题：1、Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的新鲜度。2、如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存。3、有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形。ETag是服务器自动生成或开发者生成对应资源在服务器的唯一标识符，能够更加精准控制缓存。两者可以一起使用，服务器优先验证ETag，一致时，才会继续比对Last-Mofifed，才决定是否要返回304。

## 五、不能缓存的请求

并不是所有的请求都能被缓存，无法被缓存的有：

- post 请求无法被缓存。
- 需要根据cookie、认证信息等决定输入内容的动态请求不能被缓存。
- http响应头中不包含Last-Modified/ETag，也不包含Cache-Control/Expiress的请求无法被缓存。
- http信息头明确设置Cache-Control:no-cache,pragma:no-cache或Cache-Control:max-age=0浏览器不缓存时。

## 六、对于缓存前端能做什么

| 阶段       | 可做事项                           | 目的                         |
| :--------- | :--------------------------------- | :--------------------------- |
| **构建**   | 资源指纹 (Hashing)                 | 实现精确缓存失效，性能基石   |
| **构建**   | 代码分割 (Code Splitting)          | 缩小缓存粒度，提升缓存利用率 |
| **配置**   | 提供 `.htaccess` / `_headers` 文件 | 告知服务器/CDN如何设置缓存头 |
| **运行时** | 编写 Service Worker                | 实现离线化、高级缓存策略     |
| **运行时** | 缓存 API 数据                      | 减少网络请求，提升用户体验   |
| **运行时** | 感知更新并提示用户                 | 友好地引导用户获取新版本     |
| **调试**   | 使用开发者工具验证                 | 确保缓存策略按预期工作       |

6.1、资源指纹

配置 Webpack/Vite/Rollup，使用 `[contenthash]` 或 `[chunkhash]` 作为输出文件名。

**精确的缓存失效**：文件变化后重新打包，其 url 路径会添加新的 hash 值，从而触发重新下载，未变化的文件则永远从浏览器缓存读取。



6.2、代码分割

使用动态导入 `import('./module.js')` 将代码拆分成多个按需加载的 chunk（页面级、组件级、第三方库）。

**缩小缓存粒度**：修改一个页面模块，只会使该模块对应的 chunk 哈希变化，而不会影响其他页面和庞大的 `vendor` (第三方库) chunk。极大提升了缓存利用率。



6.3、元配置

1. **配置 `.htaccess` (Apache)**：前端项目可以包含这个文件来定义缓存规则。

   ```apache
   <FilesMatch "\.(html|htm)$">
       Header set Cache-Control "no-cache"
   </FilesMatch>
   <FilesMatch "\.(js|css|png|jpg|ico|svg|woff2)$">
       Header set Cache-Control "max-age=31536000, immutable"
   </FilesMatch>
   ```

   

2. **配置 `_headers` (Netlify等)**：许多现代部署平台支持通过项目中的 `_headers` 文件设置响应头。

   ```sh
   /*
   # 首先设置默认的缓存策略，比如不缓存HTML
   Cache-Control: no-cache
   
   /assets/*
   # 然后为assets目录下的文件覆盖为长缓存
   Cache-Control: public, max-age=31536000, immutable
   ```



6.4、Service Worker

编写SW脚本，监听 `fetch` 事件，实现复杂的缓存策略（如**缓存优先、网络优先、仅缓存等**）。

```js
// service-worker.js 简化示例 (网络优先)
self.addEventListener('fetch', (event) => {
  event.respondWith(
    fetch(event.request) // 1. 先尝试网络请求
      .then((response) => {
        // 网络请求成功，克隆并缓存响应
        const clone = response.clone();
        caches.open('my-cache').then((cache) => {
          cache.put(event.request, clone);
        });
        return response;
      })
      .catch(() => caches.match(event.request)) // 2. 网络失败，回退到缓存
  );
});
```



6.5、缓存 api

可以通过 swr 库或自己实现 localStorage 等方式缓存 api 。



6.6、感知更新并提示用户

在用户界面上友好地提示用户“有新版本可用，请刷新页面”，来提升用户体验。

```js
// 示例：每小時检查一次 index.html 是否更新
setInterval(() => {
  fetch('/index.html', { cache: 'no-cache' })
    .then(res => res.text())
    .then(html => {
      const newVersion = extractVersionFromHTML(html); // 伪代码，从HTML中提取版本号
      if (newVersion !== currentVersion) {
        showUpdateNotification(); // 显示更新提示弹窗
      }
    });
}, 60 * 60 * 1000);
```



6.7、使用开发者工具验证

作为开发者可以使用开发者工具验证缓存策略是否正确工作。

1. **使用浏览器开发者工具**：
   - **Network面板**：查看每个请求的`Size`列，如果显示 `(memory cache)` 或 `(disk cache)`，则说明缓存命中。检查响应头中的 `Cache-Control` 等字段是否正确。
   - **Application面板**：查看 `Cache Storage` 和 `Local Storage` 中缓存的内容。
2. **进行 Lighthouse / PageSpeed Insights 审计**：
   - 这些工具会明确指出哪些资源缺少有效的缓存策略，并给出优化建议。