# 虚拟表格

使用虚拟列表功能实现一个，固定列、固定表头的表格

<!-- more -->

## 核心方案

1.虚拟列表

2.position: sticky 实现固定列和行

3.自定义 teleport 组件解决固定和滚动的冲突

## 表格组件

table.vue

::: detail

```vue
<template>
  <div class="myTable">
    <div class="left_fixed" :style="{ width: fixedWidth + 'px' }"></div>
    <div
      class="table_detail"
      ref="scrollContainer"
      :id="idName"
      :style="{
        height: height + 'px',
      }"
    >
      <div class="header" id="header"></div>
      <div class="phantom" :style="{ height: listHeight + 'px' }"></div>
      <table>
        <Teleport to="#header">
          <thead>
            <tr>
              <template>
                <th
                  :style="[
                    _outCellStyle({ head, columnIndex, isHeader: true }),
                  ]"
                  v-for="(head, columnIndex) in _headers"
                  :key="columnIndex"
                >
                  <div
                    class="cell"
                    :style="[_cellStyle({ head, columnIndex, isHeader: true })]"
                  >
                    {{ head.label }}
                  </div>
                </th>
              </template>
            </tr>
          </thead>
        </Teleport>
        <tbody ref="tbody">
          <tr v-for="(row, rowIndex) in visibleData" :key="rowIndex">
            <td
              :style="[_outCellStyle({ head, row, rowIndex, columnIndex })]"
              v-for="(head, columnIndex) in _headers"
              :key="columnIndex"
            >
              <div
                :id="String(row.index)"
                ref="items"
                class="cell"
                :style="[_cellStyle({ head, row, rowIndex, columnIndex })]"
              >
                <renderVue
                  v-if="head?.render"
                  :scope="{ row, head, columnIndex, rowIndex }"
                  :render="head?.render"
                />
                <template v-else>{{ row[head.prop] }}</template>
              </div>
            </td>
          </tr>
        </tbody>
        <Teleport to="#footer">
          <tfoot v-if="showFooter">
            <tr>
              <th
                :style="[_outCellStyle({ head, columnIndex, isFooter: true })]"
                v-for="(head, columnIndex) in _headers"
                :key="columnIndex"
              >
                <div
                  class="cell"
                  :style="[_cellStyle({ head, columnIndex, isFooter: true })]"
                >
                  <renderVue
                    :scope="{ head, columnIndex }"
                    :render="head?.foot"
                  />
                </div>
              </th>
            </tr>
          </tfoot>
        </Teleport>
      </table>
      <div class="footer" id="footer"></div>
    </div>
  </div>
</template>

<script>
import lodash from "lodash";
import Teleport from "./teleport.vue";
import renderVue from "../renderVue.vue";

// 1、根据预估的item高度给每个item设置top和bottom（这里的top和bottom是item距离listContainer顶部的位置）、设置列表的总高度
// 2、根据滚动容器的高度和预测高度计算出最多显示几个item
// 3、当真实的item渲染时更新每个item的top和bottom、列表的总高度
// 4、当容器滚动时，找到item.bottom<=scrollTop && item.top>scrollTop的index并设置startIndex，并更新列表的显示范围，同时更新item的top、bottom和列表的总高度
// 二分法查找 用于查找开始索引
let binarySearch = function (list, target) {
  const len = list.length;
  let left = 0,
    right = len - 1;
  let tempIndex = null;

  while (left <= right) {
    let midIndex = (left + right) >> 1;
    let midVal = list[midIndex].bottom;

    if (midVal === target) {
      return midIndex;
    } else if (midVal < target) {
      left = midIndex + 1;
    } else {
      // list不一定存在与target相等的项，不断收缩右区间，寻找最匹配的项
      if (tempIndex === null || tempIndex > midIndex) {
        tempIndex = midIndex;
      }
      right--;
    }
  }
  // 如果没有搜索到完全匹配的项 就返回最匹配的项
  return tempIndex;
};

// 随机的字符串
const randomString = () => Math.random().toString(36).slice(2);
export default {
  components: { renderVue, Teleport },
  props: {
    virtual: {
      type: Boolean,
      default: false,
    },
    height: {
      type: Number,
      default: 500,
    },
    headers: {
      type: Array,
      default: () => [],
    },
    tableData: {
      type: Array,
      default: () => [],
    },
    outCellStyle: {
      type: Function,
      default: () => {},
    },
    cellStyle: {
      type: Function,
      default: () => {},
    },
    showFooter: {
      type: Boolean,
      default: false,
    },
  },
  data() {
    return {
      idName: `table_${randomString()}`,
      scrollLeft: 0,

      listHeight: 500, // 预估容器高度
      positions: [], // 缓存列表
      preItemSize: 50, // 预估高度
      screenHeight: 0,

      start: 0,
      end: 0,
      count: 0,
      bufferPercent: 0.5, // 即每个缓冲区只缓冲 0.5 * 最大可见列表项数 个元素
    };
  },
  computed: {
    _headers() {
      return this.headers.filter((v) => v.show !== false);
    },
    _tableData() {
      return this.tableData.map((v, index) => ({ ...v, index }));
    },
    fixedWidth() {
      if (this.scrollLeft < 1) return 0;
      const newheaders = this._headers.filter((v) => v.fixed && v.width);
      const width = newheaders.reduce((c, n) => c + n.width, 0);
      return width;
    },
    visibleCount() {
      return Math.ceil(this.screenHeight / this.preItemSize);
    },
    visibleData() {
      return this.virtual
        ? this._tableData.slice(
            this.start - this.aboveCount,
            this.end + this.belowCount
          )
        : this._tableData;
    },
    bufferCount() {
      return (this.visibleCount * this.bufferPercent) >> 0; // 向下取整
    },
    // 使用索引和缓冲数量的最小值 避免缓冲不存在或者过多的数据
    aboveCount() {
      return Math.min(this.start, this.bufferCount);
    },
    belowCount() {
      return Math.min(this._tableData.length - this.end, this.bufferCount);
    },
  },
  watch: {},
  methods: {
    _outCellStyle({
      head,
      row,
      rowIndex,
      columnIndex,
      isHeader = false,
      isFooter = false,
    }) {
      const newheaders = this._headers
        .slice(0, columnIndex)
        .filter((v) => v.fixed && v.width);
      const left = newheaders.reduce((c, n) => c + n.width, 0);
      const newOutCellStyle =
        this.outCellStyle({
          head,
          row,
          rowIndex,
          columnIndex,
          isHeader,
          isFooter,
        }) || {};
      if (head.fixed && head.width) {
        return {
          position: "sticky",
          left: left + "px",
          "z-index": isHeader || isFooter ? 3 : 2,
          ...newOutCellStyle,
        };
      } else {
        return newOutCellStyle;
      }
    },
    _cellStyle({
      head,
      row,
      rowIndex,
      columnIndex,
      isHeader = false,
      isFooter = false,
    }) {
      const { width = 100 } = head;
      const newCellStyle =
        this.cellStyle({
          head,
          row,
          rowIndex,
          columnIndex,
          isHeader,
          isFooter,
        }) || {};
      const style = {
        width: width + "px",
        ...newCellStyle,
      };
      return style;
    },
    // 初始化列表
    initPositions(tableData, itemSize) {
      this.positions = tableData.map((item, index) => {
        return {
          index, // 列表项高度
          top: index * itemSize, // 列表项高度
          bottom: (index + 1) * itemSize, // 列表项高度
          height: itemSize, // 列表项高度
        };
      });
      this.listHeight = this.positions[this.positions.length - 1].bottom;
    },
    getStartIndex(scrollTop = 0) {
      return binarySearch(this.positions, scrollTop);
    },
    // 渲染后更新positions
    updatePositions() {
      let nodes = this.$refs.items;
      nodes.forEach((node) => {
        // 获取 真实DOM高度
        const { height } = node.getBoundingClientRect();
        // 根据 元素索引 获取 缓存列表对应的列表项
        const index = Number(node.id);
        let oldHeight = this.positions[index].height;
        // dValue：真实高度与预估高度的差值 决定该列表项是否要更新
        let dValue = oldHeight - height;
        // 如果有高度差 !!dValue === true
        if (dValue) {
          // 更新对应列表项的 bottom 和 height
          this.positions[index].bottom = this.positions[index].bottom - dValue;
          this.positions[index].height = height;
          // 依次更新positions中后续元素的 top bottom
          for (let k = index + 1; k < this.positions.length; k++) {
            this.positions[k].top = this.positions[k - 1].bottom;
            this.positions[k].bottom = this.positions[k].bottom - dValue;
          }
        }
      });
    },
    getCurrentOffset() {
      if (this.start >= 1) {
        // 计算偏移量时包括上缓冲区的列表项
        let size =
          this.positions[this.start].top -
          (this.positions[this.start - this.aboveCount]
            ? this.positions[this.start - this.aboveCount].top
            : 0);
        return this.positions[this.start - 1].bottom - size;
      } else {
        return 0;
      }
    },
    // 滚动回调
    scrollEvent(target) {
      const { scrollTop, scrollLeft } = target;
      this.scrollLeft = scrollLeft;
      if (this.virtual) {
        this.start = this.getStartIndex(scrollTop);
        this.end = this.start + this.visibleCount;
        const currentOffset = this.getCurrentOffset();
        this.transformBox(currentOffset);
      }
    },
    transformBox(currentOffset) {
      this.$refs.tbody.style.transform = `translate3d(0, ${currentOffset}px, 0)`;
    },
  },
  created() {},
  mounted() {
    this.initPositions(this._tableData, this.preItemSize);
    this.$nextTick(() => {
      this.screenHeight = this.$el.clientHeight;
      this.start = 0;
      this.end = this.start + this.visibleCount;
      // 绑定滚动事件
      let target = this.$refs.scrollContainer;
      let scrollFn = (event) => this.scrollEvent(event.target);
      let debounce_scroll = lodash.debounce(scrollFn, 160);
      let throttle_scroll = lodash.throttle(scrollFn, 80);
      target.addEventListener("scroll", debounce_scroll);
      target.addEventListener("scroll", throttle_scroll);
    });
  },
  updated() {
    this.$nextTick(() => {
      if (!this.$refs.items || !this.$refs.items.length) {
        return;
      }
      // 根据真实元素大小，修改对应的缓存列表
      console.log("updated");
      if (this.virtual) {
        this.updatePositions();
        // 更新完缓存列表后，重新赋值偏移量
        const currentOffset = this.getCurrentOffset();
        this.transformBox(currentOffset);
      }
    });
  },
};
</script>
<style scoped>
.myTable {
  position: relative;
}
.left_fixed {
  position: absolute;
  background-color: transparent;
  height: 100%;
  top: 0;
  box-shadow: 5px 0 10px -5px rgba(0, 0, 0, 0.24);
  z-index: 5;
}
.phantom {
  position: absolute;
  top: 0;
  right: 0;
  left: 0;
}
.header {
  width: 100%;
  position: sticky;
  top: 0;
  z-index: 2;
}
.footer {
  width: 100%;
  position: sticky;
  bottom: 0;
  z-index: 2;
}
</style>
<style lang="less" scoped>
.cell {
  box-sizing: border-box;
  padding: 10px;
}

.table_detail {
  position: relative;
  box-sizing: border-box;
  overflow: auto;
  width: 100%;
  border-top: 1px solid #ebebeb;
  border-bottom: 1px solid #ebebeb;
  border-right: 0;
  // &::-webkit-scrollbar {
  //   //隐藏滚动条
  //   display: none;
  // }
  table {
    // position: absolute;
    margin-top: 10px;
    border-collapse: collapse;
    table-layout: auto;
    width: 100%;
  }

  td,
  th {
    width: auto;
    box-sizing: border-box;
    border-bottom: 1px solid #ebebeb;
    color: #333;
    background-color: #ffffff;
    font-size: 24px;
    text-align: center;
    display: table-cell;
    z-index: 0;
  }
  th {
    background: #e8f2ff;
    color: rgba(0, 0, 0, 0.85);
  }

  // 固定表头
  // thead tr th {
  //   position: sticky;
  //   // position: relative;
  //   top: 0;
  //   z-index: 2;
  // }
  // thead {
  //   width: 100%;
  //   position: sticky;
  //   top: 0;
  //   z-index: 2;
  // }

  // 固定表头
  tfoot tr th {
    position: sticky;
    bottom: 0;
    border-bottom: 0;
    z-index: 2;
  }
}
</style>

```

:::

## telepoart组件

telepoart.vue

::: details

```vue
<script>
export default {
  name: "Teleport",
  data() {
    return {
      isMounted: false,
    };
  },
  props: {
    to: {
      // 传送目标
      type: String,
      require: true,
    },
  },
  // 挂载元素
  mounted() {
    this.isMounted = true;
    document.querySelector(this.to).appendChild(this.$el);
  },
  // 组件激活时
  activated() {
    if (this.isMounted) return;
    document.querySelector(this.to).appendChild(this.$el);
  },
  // 路由切换移除
  deactivated() {
    this.isMounted = false;
    this.$el &&
      this.$el.parentNode &&
      this.$el.parentNode.removeChild(this.$el);
  },
  // render函数渲染，使用模板的方式也是可以的
  render() {
   return <div class="teleport">{this.$scopedSlots?.default?.()}</div>;
  },
  // 组件销毁时移除
  destroyed() {
    this.isMounted = false;
    this.$el &&
      this.$el.parentNode &&
      this.$el.parentNode.removeChild(this.$el);
  },
};
</script>

```

:::

## render组件

renderVue.vue

::: details

```vue
<script>
export default {
  functional: true,
  props: {
    render: {
      type: Function,
      required: true,
    },
    scope: {
      type: Object,
      required: true,
    },
  },
  render: (h, ctx) => {
    const VNode = ctx.props.render(h, ctx.props.scope);
    return VNode;
  },
};
</script>

```

:::

## 使用

```vue
<template>
  <div>
    <mobileTable
      virtual
      :headers="headers"
      :tableData="tableData"
      :cellStyle="cellStyle"
      :outCellStyle="outCellStyle"
    />
  </div>
</template>
<script>
import mobileTable from "./mobileTable/index.vue";

export default {
  components: { sectionTitle, mobileTable },
  data() {
    return {
      buttonTabs: {
        active: 0,
        list: [
          {
            active: 0,
            text: "初步设计阶段",
          },
          {
            active: 1,
            text: "施工图阶段",
          },
          {
            active: 2,
            text: "竣工图",
          },
        ],
      },
      headers: [
        {
          prop: "name",
          align: "center",
          label: "姓名",
          fixed: true,
          width: 70,
        },
        {
          prop: "age",
          align: "center",
          fixed: true,
          label: "年龄",
          width: 50,
        },
        {
          prop: "city",
          align: "center",
          label: "城市",
        },
        {
          prop: "hobby",
          align: "center",
          label: "爱好",
        },
        {
          prop: "other",
          align: "center",
          label: "其他",
        },
      ],
      tableData: [],
    };
  },
  computed: {},
  watch: {},
  methods: {
    handleButtonTabsChange(item) {
      this.buttonTabs.active = item.active;
    },
    phoneCall(phone) {
      window.location.href = `tel:${phone}`;
    },
    cellStyle(options) {
      if (options.isHeader) {
        return {
          height: "50px",
          lineHeight: "35px",
        };
      }
    },
    outCellStyle(options) {
      let style = {};

      if (options.rowIndex === 1) {
        style.background = "#e8f2ff";
      }
      return style;
    },
    initData() {
      const arr = [];
      for (let i = 0; i < 1000; i++) {
        arr.push({
          name: "张三" + i,
          age: 18,
          city: "杭州",
          hobby: "写代码",
          other:
            "阿达大大大叔大婶哒哒哒哒哒四大四大四大四大asdasda阿达阿达阿达撒啊阿达大大的",
        });
        arr.push({
          name: "李四" + i,
          age: 20,
          city: "上海",
          hobby: "搞事情",
          other: "123456",
        });
      }
      this.tableData = arr;
    },
  },
  created() {
    this.initData();
  },
  mounted() {},
};
</script>

```

## 效果

![image-20240723164334208](https://s2.loli.net/2024/07/23/QXoErxRfujUhYdV.png)