# 快速入门JS

## ES6

### 解构赋值

```js
// 数组解构
let [a, b, c] = [1, 2, 3];
console.log(a, b, c)

// 对象解构
let {e, f, g:newg} = {e:1,f:2,g:3};
console.log(e, f, g,newg)

// 函数参数的解构
function move({x = 0, y} = {}) {
  return [x, y];
}
console.log(move())
console.log(move({x:1,y:2}))
console.log(move({y:2}))
```

解构与拓展运算符

```js
let {e, ...z} = {e:1,f:2,g:3};
console.log(e, z)
```

合并数据

```js
const obj1={a:1,b:2,c:3}
const obj2={a:2,d:4,c:5}
const newobj={...obj1,...obj2}
console.log(newobj)
```

### 模块的导入导出

如何在一个文件中使用另一个文件中定义的方法或变量？

#### 导出

文件 util.js：

```js
const data={a:1,b:2}
function fun1(){
	console.log('fun1')
}
// 单独导出
export {
	data,fun1
}
// 默认导出
export default fun1
```

#### 引入

文件 main.js:

```js
// 单独引入
import {data,fun1} from './util.js'
// 默认引入
import fun1 from './util.js'

// 就可以在这个文件中使用上面引入的方法、数据了
fun1()
console.log(data)
```

### 模板字符串

当一个字符串是由多个变量组合而成的，我们可以使用模板字符创进行拼接

```js
const name = 'jack';
const age = '23'
const str=`${name} - ${age}`
console.log(str)
```

### 箭头函数

函数的两种定义方法：

1.函数声明

```js
function fun1(){
    console.log('fun1')
}
```

2.箭头函数

```js
const fun2=()=>{
    cosnole.log('fun2')
}
```

::: tip 注意

函数声明的函数具有完整的函数作用域，

箭头函数声明的作用域来自其上一级作用域

主要体现在 this 的使用上。

::: 

举个:chestnut:：

```js
function fun1(){
    console.log(this,'fun1')
}
const fun2=()=>{
    console.log(this,'fun2')
}
const a=456
const obj1={
    a:123,
    fun1:fun1,
    fun2:fun2
}
obj1.fun1()
obj1.fun2()

```

### 可迭代的异步任务

```js
const request=(value)=>{
    return new Promise((resolve)=>{
        setTimeout(()=>{
            console.log(value)
            resolve(value)
        },1000)
    })
}

const fun1=()=>{
    request(1)
    console.log(2)
}
const fun2=async ()=>{
    await request(1)
    console.log(2)
}

fun1()
fun2()
```

> async 和 await 必须组合起来使用，且 async 会将声明的函数转化为异步任务（Promise）

## JS中的常见问题

### 浮点数溢出

js 中由于进制转化的精度问题进行数字计算时可能会导致浮点数溢出

```js
0.1 + 0.2 // 0.30000000000000004
```

解决方法：

使用计算工具进行处理

```js
(0.1 + 0.2).toFix()
```

### JS 中的假值

进行条件判断时有六种值会被评定为假值

undefined、null、NaN、0、""、false

```js
console.log(!undefined,!null,!NaN,!0,!"",!false)
```

### 双等与全等

双等

```js
console.log(1 == 2) // false
console.log(1 == 1) // true
console.log(1 == '1') // true
console.log(null == undefined) // true
```

全等

```js
console.log(1 === 2) // false
console.log(1 === 1) // true
console.log(1 === '1') // false
console.log(null === undefined) // false
```

> 双等和全等的最大区别是，双等只匹配值是否相等，而全等则会对类型和值都进行匹配

### 处理异步编程的异常

Promise:

```js
const request=(value)=>{
    return new Promise((resolve,reject)=>{
        setTimeout(()=>{
            reject(value)
        },1000)
    })
}
request('err').catch(err=>{
    console.log(err)
})

```

async/await:

```js
const request=(value)=>{
    return new Promise((resolve,reject)=>{
        setTimeout(()=>{
            reject(value)
        },1000)
    })
}

try{
 	await request('err')
}catch(err){
	console.log(err)
}
```

## 前端常用的调试手段

dubugger 断点和 console.log()

```js
console.log(123)
debugger
console.log(456)
```

## 利用浏览器缓存数据

### localStorage

> 持久化的储存

```js
// 存储
localStorage.setItem("lastname", "Gates");
// 取回
localStorage.getItem("lastname");
```

### sessionStorage

> 当前浏览器缓存，当你关闭浏览器时，储存的数据会被清空

```js
// 存储
sessionStorage.setItem("lastname", "Gates");
// 取回
sessionStorage.getItem("lastname");
```

